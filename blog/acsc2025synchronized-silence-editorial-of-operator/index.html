<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>DoubleMnSingleH</title>
<meta name="keywords" content="">
<meta name="description" content="TL; DR Tree Parity Machine(TPM)을 이용해 AES 키를 공개 채널에서 학습 동기화로 생성한 뒤, 암호화된 플래그를 제공하는 문제다. 로그(log.json)를 기반으로 TPM weight를 재현하고, SHA256으로 키를 유도해 enc_flag.txt를 복호화하면 된다. naive한 단일 TPM imitation으로는 풀리지 않으며, population attack, mutation, selective unit flipping을 활용해 풀이 가능하다.
문제 구조 log.json: TPM 학습 로그. 각 step의 입력 벡터(x: 3x100)와 출력 bit(tau: {-1, &#43;1})가 주어짐. 단, Alice와 Bob이 tau^A = tau^B일 때만 기록됨. enc_flag.txt: AES-ECB로 암호화된 플래그.">
<meta name="author" content="">
<link rel="canonical" href="https://zero.shotlearni.ng/blog/acsc2025synchronized-silence-editorial-of-operator/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.a4e69204638e6704374d8280b361c637c9345cbe356eeb3414645f753ed82835.css" integrity="sha256-pOaSBGOOZwQ3TYKAs2HGN8k0XL41bus0FGRfdT7YKDU=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.b95bacdc39e37a332a9f883b1e78be4abc1fdca2bc1f2641f55e3cd3dabd4d61.js" integrity="sha256-uVus3DnjejMqn4g7Hni&#43;Srwf3KK8HyZB9V4809q9TWE="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://zero.shotlearni.ng/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://zero.shotlearni.ng/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://zero.shotlearni.ng/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://zero.shotlearni.ng/apple-touch-icon.png">
<link rel="mask-icon" href="https://zero.shotlearni.ng/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="" />
<meta property="og:description" content="TL; DR Tree Parity Machine(TPM)을 이용해 AES 키를 공개 채널에서 학습 동기화로 생성한 뒤, 암호화된 플래그를 제공하는 문제다. 로그(log.json)를 기반으로 TPM weight를 재현하고, SHA256으로 키를 유도해 enc_flag.txt를 복호화하면 된다. naive한 단일 TPM imitation으로는 풀리지 않으며, population attack, mutation, selective unit flipping을 활용해 풀이 가능하다.
문제 구조 log.json: TPM 학습 로그. 각 step의 입력 벡터(x: 3x100)와 출력 bit(tau: {-1, &#43;1})가 주어짐. 단, Alice와 Bob이 tau^A = tau^B일 때만 기록됨. enc_flag.txt: AES-ECB로 암호화된 플래그." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://zero.shotlearni.ng/blog/acsc2025synchronized-silence-editorial-of-operator/" /><meta property="article:section" content="blog" />



<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content=""/>
<meta name="twitter:description" content="TL; DR Tree Parity Machine(TPM)을 이용해 AES 키를 공개 채널에서 학습 동기화로 생성한 뒤, 암호화된 플래그를 제공하는 문제다. 로그(log.json)를 기반으로 TPM weight를 재현하고, SHA256으로 키를 유도해 enc_flag.txt를 복호화하면 된다. naive한 단일 TPM imitation으로는 풀리지 않으며, population attack, mutation, selective unit flipping을 활용해 풀이 가능하다.
문제 구조 log.json: TPM 학습 로그. 각 step의 입력 벡터(x: 3x100)와 출력 bit(tau: {-1, &#43;1})가 주어짐. 단, Alice와 Bob이 tau^A = tau^B일 때만 기록됨. enc_flag.txt: AES-ECB로 암호화된 플래그."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Blogs",
      "item": "https://zero.shotlearni.ng/blog/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "",
      "item": "https://zero.shotlearni.ng/blog/acsc2025synchronized-silence-editorial-of-operator/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "",
  "name": "",
  "description": "TL; DR Tree Parity Machine(TPM)을 이용해 AES 키를 공개 채널에서 학습 동기화로 생성한 뒤, 암호화된 플래그를 제공하는 문제다. 로그(log.json)를 기반으로 TPM weight를 재현하고, SHA256으로 키를 유도해 enc_flag.txt를 복호화하면 된다. naive한 단일 TPM imitation으로는 풀리지 않으며, population attack, mutation, selective unit flipping을 활용해 풀이 가능하다.\n문제 구조 log.json: TPM 학습 로그. 각 step의 입력 벡터(x: 3x100)와 출력 bit(tau: {-1, +1})가 주어짐. 단, Alice와 Bob이 tau^A = tau^B일 때만 기록됨. enc_flag.txt: AES-ECB로 암호화된 플래그.",
  "keywords": [
    
  ],
  "articleBody": "TL; DR Tree Parity Machine(TPM)을 이용해 AES 키를 공개 채널에서 학습 동기화로 생성한 뒤, 암호화된 플래그를 제공하는 문제다. 로그(log.json)를 기반으로 TPM weight를 재현하고, SHA256으로 키를 유도해 enc_flag.txt를 복호화하면 된다. naive한 단일 TPM imitation으로는 풀리지 않으며, population attack, mutation, selective unit flipping을 활용해 풀이 가능하다.\n문제 구조 log.json: TPM 학습 로그. 각 step의 입력 벡터(x: 3x100)와 출력 bit(tau: {-1, +1})가 주어짐. 단, Alice와 Bob이 tau^A = tau^B일 때만 기록됨. enc_flag.txt: AES-ECB로 암호화된 플래그. implementation.py : 구조체 README.md : 걍 시나리오, 목표 출제의도 TPM은 neural cryptography에서 양측이 키를 공유하는 방식이다. 학습 기반 키 교환이 비동기적으로 이루어지고, 공개된 채널에서 이뤄진다는 점이 매력 적이지만, 공격자의 입장에서 동기화된 키를 재현가능 함.\n해당 문제는 4가지의 근복적 취약점이 있다\n출력 공개 동기식 업데이트 (weight 경로의 결정성) 상태공간의 유한성 학습 규칙의 공개 취약점 분석 1. Tree Parity Machine(TPM)의 형식적 정의 구조\n은닉층 뉴런 K=3 각 뉴런 입력 차원 N=100 가중치 범위 $w_{k,j}\\in{-L,\\dots,L},;L=3$ 국소장(local field)\n$h_k(t)=\\sum_{j=1}^{N}w_{k,j}(t),x_{k,j}(t),\\qquad \\sigma_k(t)=\\operatorname{sgn}!\\bigl(h_k(t)\\bigr)$\n(0은 +1로 치환)\n출력 비트\n$\\tau(t)=\\prod_{k=1}^{K}\\sigma_k(t)\\in{-1,+1}$\n이 값만이 공개 채널을 통해 누설된다.\nHebbian 학습 규칙\n$w_{k,j}(t+1)=g!\\Bigl(w_{k,j}(t)+\\sigma_k(t),x_{k,j}(t),\\Theta!\\bigl(\\sigma_k(t)\\tau(t)\\bigr)\\Bigr)$\n여기서 $g(\\cdot)$는 범위를 자르는 함수이고 $\\Theta$는 부호 일치 여부(0/1) 지시자다 .\n2. 출력 공개 공격자가 시퀀스\n$\\bigl{x(t),\\tau(t)\\bigr}{t=1}^{T}$\n를 얻을 때, 한 스텝에서 숨겨진 $\\sigma_k$ 3비트 중 알려지는 정보량은 1 bit뿐이다.\n엔트로피 관점에서\n$H\\bigl(\\sigma_1,\\sigma_2,\\sigma_3\\bigr)=3 ,\\qquad H\\bigl(\\sigma_1,\\sigma_2,\\sigma_3\\mid\\tau)=2$\n즉 한 스텝당 1 bit가 그대로 남는다. 스텝의 로그는\n$I{\\text{leak}} = T\\text{ bit}$\n을 노출하며, 이는 가중치 공간\n$(2L+1)^{KN}=7^{300}$\n에 비하면 작지만 selection-filtering 과 결합될 때 치명적이다.\n3. Population Attack 초기화 $n_0$개의 후보 가중치 벡터 ${W_i^{(0)}}$를 무작위로 뽑음\n필터 단계\n$P_{t+1}= \\Bigl{,g\\bigl(W_i^{(t)},x(t),\\tau(t)\\bigr);|;\\tau\\bigl(W_i^{(t)},x(t)\\bigr)=\\tau(t)\\Bigr}$\n여기서 g는 Hebbian update 연산.\n크기 기대값\n각 스텝의 생존 확률은\n$p_{\\text{match}}(t)=\\Pr\\bigl[\\tau(W,x)=\\tau(t)\\bigr]\\approx\\frac12\\bigl(1+\\epsilon_t\\bigr)$\n(무작위 가중치면 $\\epsilon_t\\approx0$)\n따라서\n$\\mathbb E!\\bigl[|\\mathcal P_{t}|\\bigr]=n_0,\\prod_{s=1}^{t-1}p_{\\text{match}}(s)$\n로그 길이가 충분하면 $|\\mathcal P_{t}|\\to0$ → 실패. 이를 선택적 플립과 돌연변이로 보완\n4. Selective Unit Flipping 공격자가 $\\tau_{\\text{pred}}\\neq\\tau$인 스텝에서\n$k^\\ast = \\arg\\min_k \\left| h_k \\right|$\n을 찾아 $\\sigma_{k^\\ast} \\leftarrow -\\sigma_{k^\\ast}$ 로 강제 전환하면 새 출력 **$\\tau’ = -\\tau_{\\text{pred}}$\n즉 정확히 한 비트 반전으로 불일치 해소가 가능할 확률은\n$P_{\\text{flip}} = \\Pr\\left[ \\operatorname{sgn}(h_{k^\\ast}) \\neq 0 \\right] \\approx 1$\n(국소장이 0이면 이미 $\\tau$ 일치였음).\n필터 손실을 $O(1)$로 줄여 $|\\mathcal P_t|$ 붕괴를 방지 가능함\n5. Mutation Strategy 필터+플립에도 집단 다양성이 급감하면 탐색이 지수적으로 느려진다.\n이를 해결하기 위해 남은 개체 W마다\n$W’;=;W+\\Delta W,\\qquad \\Delta W_{k,j}\\sim{-1,0,+1}$\n를 확률 $p_m$로 삽입, 전이 행렬 M을 두면\n$\\mathbf n_{t+1}= \\mathbf n_t P_{\\text{filter}} + \\mathbf n_t M$\nM이 가중치 랜덤 워크를 부여하여 마코프 체인의 미소 공간 접근성을 보장\n6. 공격 성공 확률 \u0026 시간 복잡도 $P_{\\text{sync}}^{\\text{Eve}}(T)\\approx1-\\exp!\\bigl(-\\alpha,T/n_0\\bigr)$, $\\alpha\\propto\\frac{1}{(2L+1)^N}$\n동일 파라미터에서 50 k 개체, 10 k 스텝이면 $P_{\\text{sync}}\\to0.9$ 수준\n연산량은 GPU 없이도 수 분–수십 분 내 실행 가능\n$O(n_0 K N T)\\approx 5!\\times!10^4\\cdot3\\cdot100\\cdot10^4\\approx1.5!\\times!10^{9}$\n7. 키 파생 공식 가중치 행렬 W를 시프트 \u0026 3진법 인코딩 → 비트열 $b$ →\n$K_{\\text{AES}}=\\operatorname{Trunc}_{128}!\\Bigl(\\operatorname{SHA256}\\bigl(\\mathbf b\\bigr)\\Bigr)$\n이는 가중치 1 bit라도 틀리면 해시가 전혀 달라지므로 공격자에게 완전체 동기화를 강제.\n솔버 위 수식들 기반으로 솔버 작성하면\nimport json import numpy as np from Crypto.Cipher import AES import hashlib import random K, N, L = 3, 100, 3 psize = 50000 b = [-1, 0, 1] mthreshold = 100 mfactor = psize // 5 def tpm_output(w, x): dot = np.einsum('ij,ij-\u003ei', w, x) sig = np.sign(dot) sig[sig == 0] = 1 tau = np.prod(sig) return tau, sig, dot def update_weights(w, x, sig, tau): for i in range(K): if sig[i] == tau: w[i] += x[i] w[i] = np.clip(w[i], -L, L) return w def weight_to_aes_key(w): bits = ''.join(f'{(v + L):03b}' for v in w.flatten()) b = int(bits, 2).to_bytes((len(bits) + 7) // 8, byteorder='big') return hashlib.sha256(b).digest()[:16] def load(): with open(\"log.json\") as f: log = json.load(f) with open(\"enc_flag.txt\", \"rb\") as f: ct = f.read() return log, ct def biased_init(): return np.random.choice(b, size=(K, N)) def mutate(w, strength=1): mutation = np.random.randint(-strength, strength + 1, size=w.shape) return np.clip(w + mutation, -L, L) def population_attack(): log, ct = load() population = [biased_init() for _ in range(psize)] for t, entry in enumerate(log): x = np.array(entry['x']) tau_true = entry['tau'] new_pop = [] for w in population: tau_pred, sig, dot = tpm_output(w, x) if tau_pred == tau_true: new_pop.append(update_weights(w.copy(), x, sig, tau_true)) else: i_star = np.argmin(np.abs(dot)) sig[i_star] *= -1 tau_flip = np.prod(sig) if tau_flip == tau_true: new_pop.append(update_weights(w.copy(), x, sig, tau_true)) population = new_pop print(f\"[Step {t:03d}] Population: {len(population)}\") if len(population) == 0: print(\"[-] nono \") return if len(population) \u003c mthreshold: print(f\"[*] Low survivors ({len(population)}), mutating...\") survivors = population.copy() population = [] for w in survivors: for _ in range(mfactor // max(1, len(survivors))): population.append(mutate(w, strength=1)) print(f\"[*]New population after mutation: {len(population)}\") print(f\"[*]{len(population)} survivors. Trying AES decryption...\") for w in population: key = weight_to_aes_key(w) pt = AES.new(key, AES.MODE_ECB).decrypt(ct) if b\"acsc{\" in pt: print(pt.decode(errors=\"ignore\")) return if __name__ == \"__main__\": population_attack() ",
  "wordCount" : "731",
  "inLanguage": "en",
  "datePublished": "0001-01-01T00:00:00Z",
  "dateModified": "0001-01-01T00:00:00Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://zero.shotlearni.ng/blog/acsc2025synchronized-silence-editorial-of-operator/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "DoubleMnSingleH",
    "logo": {
      "@type": "ImageObject",
      "url": "https://zero.shotlearni.ng/favicon.ico"
    }
  }
}
</script><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/all.min.css">

</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<script async src="https://www.googletagmanager.com/gtag/js?id=G-P2FSMQE5SL"></script>
<script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'G-P2FSMQE5SL');
</script>

<header class="header sticky-header">
    <nav class="nav">
        <div class="logo">
            <a href="https://zero.shotlearni.ng/" accesskey="h" title="DoubleMnSingleH (Alt + H)">DoubleMnSingleH</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="https://zero.shotlearni.ng/about" title="About">
                    <span>About</span>
                </a>
            </li>
            <li>
                <a href="https://zero.shotlearni.ng/home/" title="Home">
                    <span>Home</span>
                </a>
            </li>
            <li>
                <a href="https://zero.shotlearni.ng/blog" title="Blog">
                    <span>Blog</span>
                </a>
            </li>
            <li>
                <a href="https://zero.shotlearni.ng/search" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://zero.shotlearni.ng/">Home</a>&nbsp;»&nbsp;<a href="https://zero.shotlearni.ng/blog/">Blogs</a></div>
    <h1 class="post-title">
      
    </h1>
    <div class="post-meta">



</div>
  </header> 
  <div class="post-content"><h2 id="tl-dr"><strong>TL; DR</strong><a hidden class="anchor" aria-hidden="true" href="#tl-dr">#</a></h2>
<p>Tree Parity Machine(TPM)을 이용해 AES 키를 공개 채널에서 학습 동기화로 생성한 뒤, 암호화된 플래그를 제공하는 문제다. 로그(log.json)를 기반으로 TPM weight를 재현하고, SHA256으로 키를 유도해 enc_flag.txt를 복호화하면 된다. naive한 단일 TPM imitation으로는 풀리지 않으며,  population attack, mutation, selective unit flipping을 활용해 풀이 가능하다.</p>
<h2 id="문제-구조"><strong>문제 구조</strong><a hidden class="anchor" aria-hidden="true" href="#문제-구조">#</a></h2>
<ul>
<li>log.json: TPM 학습 로그. 각 step의 입력 벡터(x: 3x100)와 출력 bit(tau: {-1, +1})가 주어짐. 단, Alice와 Bob이 tau^A = tau^B일 때만 기록됨.</li>
<li>enc_flag.txt: AES-ECB로 암호화된 플래그.</li>
<li>implementation.py : 구조체</li>
<li>README.md : 걍 시나리오, 목표</li>
</ul>
<h2 id="출제의도"><strong>출제의도</strong><a hidden class="anchor" aria-hidden="true" href="#출제의도">#</a></h2>
<p>TPM은 neural cryptography에서 양측이 키를 공유하는 방식이다. 학습 기반 키 교환이 비동기적으로 이루어지고, 공개된 채널에서 이뤄진다는 점이 매력 적이지만, 공격자의 입장에서 동기화된 키를 재현가능 함.</p>
<p>해당 문제는 4가지의 근복적 취약점이 있다</p>
<ol>
<li>출력 공개</li>
<li>동기식 업데이트 (weight 경로의 결정성)</li>
<li>상태공간의 유한성</li>
<li>학습 규칙의 공개</li>
</ol>
<h2 id="취약점-분석">취약점 분석<a hidden class="anchor" aria-hidden="true" href="#취약점-분석">#</a></h2>
<h3 id="1-tree-parity-machinetpm의-형식적-정의"><strong>1. Tree Parity Machine(TPM)의 형식적 정의</strong><a hidden class="anchor" aria-hidden="true" href="#1-tree-parity-machinetpm의-형식적-정의">#</a></h3>
<ul>
<li>
<p><strong>구조</strong></p>
<ul>
<li>은닉층 뉴런 K=3</li>
<li>각 뉴런 입력 차원 N=100</li>
<li>가중치 범위 $w_{k,j}\in{-L,\dots,L},;L=3$</li>
</ul>
</li>
<li>
<p><strong>국소장(local field)</strong></p>
<p>$h_k(t)=\sum_{j=1}^{N}w_{k,j}(t),x_{k,j}(t),\qquad
\sigma_k(t)=\operatorname{sgn}!\bigl(h_k(t)\bigr)$</p>
<p>(0은 +1로 치환)</p>
</li>
<li>
<p><strong>출력 비트</strong></p>
<p>$\tau(t)=\prod_{k=1}^{K}\sigma_k(t)\in{-1,+1}$</p>
<p>이 값만이 공개 채널을 통해 누설된다.</p>
</li>
<li>
<p><strong>Hebbian 학습 규칙</strong></p>
<p>$w_{k,j}(t+1)=g!\Bigl(w_{k,j}(t)+\sigma_k(t),x_{k,j}(t),\Theta!\bigl(\sigma_k(t)\tau(t)\bigr)\Bigr)$</p>
<p>여기서 $g(\cdot)$는 범위를 자르는 함수이고 $\Theta$는 부호 일치 여부(0/1) 지시자다 .</p>
</li>
</ul>
<hr>
<h3 id="2-출력-공개"><strong>2. 출력 공개</strong><a hidden class="anchor" aria-hidden="true" href="#2-출력-공개">#</a></h3>
<p>공격자가 시퀀스</p>
<p>$\bigl{x(t),\tau(t)\bigr}{t=1}^{T}$</p>
<p>를 얻을 때, 한 스텝에서 숨겨진 $\sigma_k$ 3비트 중 알려지는 정보량은 <strong>1 bit</strong>뿐이다.</p>
<p><em>엔트로피 관점에서</em></p>
<p>$H\bigl(\sigma_1,\sigma_2,\sigma_3\bigr)=3
,\qquad
H\bigl(\sigma_1,\sigma_2,\sigma_3\mid\tau)=2$</p>
<p>즉 <strong>한 스텝당 1 bit</strong>가 그대로 남는다. 스텝의 로그는</p>
<p>$I{\text{leak}} = T\text{ bit}$</p>
<p>을 노출하며, 이는 가중치 공간</p>
<p>$(2L+1)^{KN}=7^{300}$</p>
<p>에 비하면 작지만 selection-filtering 과 결합될 때 치명적이다.</p>
<hr>
<h3 id="3-population-attack"><strong>3. Population Attack</strong><a hidden class="anchor" aria-hidden="true" href="#3-population-attack">#</a></h3>
<ol>
<li>
<p><strong>초기화</strong> $n_0$개의 후보 가중치 벡터 ${W_i^{(0)}}$를 무작위로 뽑음</p>
</li>
<li>
<p><strong>필터 단계</strong></p>
<p>$P_{t+1}= \Bigl{,g\bigl(W_i^{(t)},x(t),\tau(t)\bigr);|;\tau\bigl(W_i^{(t)},x(t)\bigr)=\tau(t)\Bigr}$</p>
<p>여기서 g는 Hebbian update 연산.</p>
</li>
<li>
<p><strong>크기 기대값</strong></p>
<p>각 스텝의 생존 확률은</p>
<p>$p_{\text{match}}(t)=\Pr\bigl[\tau(W,x)=\tau(t)\bigr]\approx\frac12\bigl(1+\epsilon_t\bigr)$</p>
<p>(무작위 가중치면 $\epsilon_t\approx0$)</p>
<p>따라서</p>
<p>$\mathbb E!\bigl[|\mathcal P_{t}|\bigr]=n_0,\prod_{s=1}^{t-1}p_{\text{match}}(s)$</p>
<p>로그 길이가 충분하면 $|\mathcal P_{t}|\to0$ → 실패. 이를 <strong>선택적 플립</strong>과 <strong>돌연변이</strong>로 보완</p>
</li>
</ol>
<hr>
<h3 id="4-selective-unit-flipping"><strong>4. Selective Unit Flipping</strong><a hidden class="anchor" aria-hidden="true" href="#4-selective-unit-flipping">#</a></h3>
<ul>
<li>
<p>공격자가 $\tau_{\text{pred}}\neq\tau$인 스텝에서</p>
<p>$k^\ast = \arg\min_k \left| h_k \right|$</p>
<p>을 찾아 $\sigma_{k^\ast} \leftarrow -\sigma_{k^\ast}$ 로 강제 전환하면 새 출력 **$\tau’ = -\tau_{\text{pred}}$</p>
<p>즉 정확히 한 비트 반전으로 불일치 해소가 가능할 확률은</p>
<p>$P_{\text{flip}} = \Pr\left[ \operatorname{sgn}(h_{k^\ast}) \neq 0 \right] \approx 1$</p>
<p>(국소장이 0이면 이미 $\tau$ 일치였음).</p>
</li>
<li>
<p>필터 손실을 $O(1)$로 줄여 $|\mathcal P_t|$ 붕괴를 방지 가능함</p>
</li>
</ul>
<hr>
<h3 id="5-mutation-strategy"><strong>5. Mutation Strategy</strong><a hidden class="anchor" aria-hidden="true" href="#5-mutation-strategy">#</a></h3>
<p>필터+플립에도 집단 다양성이 급감하면 탐색이 지수적으로 느려진다.</p>
<p>이를 해결하기 위해 남은 개체 W마다</p>
<p>$W’;=;W+\Delta W,\qquad
\Delta W_{k,j}\sim{-1,0,+1}$</p>
<p>를 확률 $p_m$로 삽입, <strong>전이 행렬</strong> M을 두면</p>
<p>$\mathbf n_{t+1}= \mathbf n_t P_{\text{filter}} + \mathbf n_t M$</p>
<p>M이 <strong>가중치 랜덤 워크</strong>를 부여하여 마코프 체인의 미소 공간 접근성을 보장</p>
<hr>
<h3 id="6-공격-성공-확률--시간-복잡도"><strong>6. 공격 성공 확률 &amp; 시간 복잡도</strong><a hidden class="anchor" aria-hidden="true" href="#6-공격-성공-확률--시간-복잡도">#</a></h3>
<p>$P_{\text{sync}}^{\text{Eve}}(T)\approx1-\exp!\bigl(-\alpha,T/n_0\bigr)$, $\alpha\propto\frac{1}{(2L+1)^N}$</p>
<p>동일 파라미터에서 <strong>50 k 개체, 10 k 스텝</strong>이면 $P_{\text{sync}}\to0.9$ 수준</p>
<p>연산량은 GPU 없이도 수 분–수십 분 내 실행 가능</p>
<p>$O(n_0 K N T)\approx 5!\times!10^4\cdot3\cdot100\cdot10^4\approx1.5!\times!10^{9}$</p>
<hr>
<h3 id="7-키-파생-공식"><strong>7. 키 파생 공식</strong><a hidden class="anchor" aria-hidden="true" href="#7-키-파생-공식">#</a></h3>
<p>가중치 행렬 W를 시프트 &amp; 3진법 인코딩 → 비트열 $b$ →</p>
<p>$K_{\text{AES}}=\operatorname{Trunc}_{128}!\Bigl(\operatorname{SHA256}\bigl(\mathbf b\bigr)\Bigr)$</p>
<p>이는 <strong>가중치 1 bit라도 틀리면 해시가 전혀 달라지므로</strong> 공격자에게 완전체 동기화를 강제.</p>
<h2 id="솔버">솔버<a hidden class="anchor" aria-hidden="true" href="#솔버">#</a></h2>
<p>위 수식들 기반으로 솔버 작성하면</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-python" data-lang="python"><span style="display:flex;"><span><span style="color:#f92672">import</span> json
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> numpy <span style="color:#66d9ef">as</span> np
</span></span><span style="display:flex;"><span><span style="color:#f92672">from</span> Crypto.Cipher <span style="color:#f92672">import</span> AES
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> hashlib
</span></span><span style="display:flex;"><span><span style="color:#f92672">import</span> random
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>K, N, L <span style="color:#f92672">=</span> <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">100</span>, <span style="color:#ae81ff">3</span>
</span></span><span style="display:flex;"><span>psize <span style="color:#f92672">=</span> <span style="color:#ae81ff">50000</span>
</span></span><span style="display:flex;"><span>b <span style="color:#f92672">=</span> [<span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">1</span>]
</span></span><span style="display:flex;"><span>mthreshold <span style="color:#f92672">=</span> <span style="color:#ae81ff">100</span>
</span></span><span style="display:flex;"><span>mfactor <span style="color:#f92672">=</span> psize <span style="color:#f92672">//</span> <span style="color:#ae81ff">5</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">tpm_output</span>(w, x):
</span></span><span style="display:flex;"><span>    dot <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>einsum(<span style="color:#e6db74">&#39;ij,ij-&gt;i&#39;</span>, w, x)
</span></span><span style="display:flex;"><span>    sig <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>sign(dot)
</span></span><span style="display:flex;"><span>    sig[sig <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>] <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>    tau <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>prod(sig)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> tau, sig, dot
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">update_weights</span>(w, x, sig, tau):
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> i <span style="color:#f92672">in</span> range(K):
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> sig[i] <span style="color:#f92672">==</span> tau:
</span></span><span style="display:flex;"><span>            w[i] <span style="color:#f92672">+=</span> x[i]
</span></span><span style="display:flex;"><span>            w[i] <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>clip(w[i], <span style="color:#f92672">-</span>L, L)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> w
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">weight_to_aes_key</span>(w):
</span></span><span style="display:flex;"><span>    bits <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;&#39;</span><span style="color:#f92672">.</span>join(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#39;</span><span style="color:#e6db74">{</span>(v <span style="color:#f92672">+</span> L)<span style="color:#e6db74">:</span><span style="color:#e6db74">03b</span><span style="color:#e6db74">}</span><span style="color:#e6db74">&#39;</span> <span style="color:#66d9ef">for</span> v <span style="color:#f92672">in</span> w<span style="color:#f92672">.</span>flatten())
</span></span><span style="display:flex;"><span>    b <span style="color:#f92672">=</span> int(bits, <span style="color:#ae81ff">2</span>)<span style="color:#f92672">.</span>to_bytes((len(bits) <span style="color:#f92672">+</span> <span style="color:#ae81ff">7</span>) <span style="color:#f92672">//</span> <span style="color:#ae81ff">8</span>, byteorder<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;big&#39;</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> hashlib<span style="color:#f92672">.</span>sha256(b)<span style="color:#f92672">.</span>digest()[:<span style="color:#ae81ff">16</span>]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">load</span>():
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">with</span> open(<span style="color:#e6db74">&#34;log.json&#34;</span>) <span style="color:#66d9ef">as</span> f:
</span></span><span style="display:flex;"><span>        log <span style="color:#f92672">=</span> json<span style="color:#f92672">.</span>load(f)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">with</span> open(<span style="color:#e6db74">&#34;enc_flag.txt&#34;</span>, <span style="color:#e6db74">&#34;rb&#34;</span>) <span style="color:#66d9ef">as</span> f:
</span></span><span style="display:flex;"><span>        ct <span style="color:#f92672">=</span> f<span style="color:#f92672">.</span>read()
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> log, ct
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">biased_init</span>():
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> np<span style="color:#f92672">.</span>random<span style="color:#f92672">.</span>choice(b, size<span style="color:#f92672">=</span>(K, N))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">mutate</span>(w, strength<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>):
</span></span><span style="display:flex;"><span>    mutation <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>random<span style="color:#f92672">.</span>randint(<span style="color:#f92672">-</span>strength, strength <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>, size<span style="color:#f92672">=</span>w<span style="color:#f92672">.</span>shape)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">return</span> np<span style="color:#f92672">.</span>clip(w <span style="color:#f92672">+</span> mutation, <span style="color:#f92672">-</span>L, L)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">def</span> <span style="color:#a6e22e">population_attack</span>():
</span></span><span style="display:flex;"><span>    log, ct <span style="color:#f92672">=</span> load()
</span></span><span style="display:flex;"><span>    population <span style="color:#f92672">=</span> [biased_init() <span style="color:#66d9ef">for</span> _ <span style="color:#f92672">in</span> range(psize)]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> t, entry <span style="color:#f92672">in</span> enumerate(log):
</span></span><span style="display:flex;"><span>        x <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>array(entry[<span style="color:#e6db74">&#39;x&#39;</span>])
</span></span><span style="display:flex;"><span>        tau_true <span style="color:#f92672">=</span> entry[<span style="color:#e6db74">&#39;tau&#39;</span>]
</span></span><span style="display:flex;"><span>        new_pop <span style="color:#f92672">=</span> []
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">for</span> w <span style="color:#f92672">in</span> population:
</span></span><span style="display:flex;"><span>            tau_pred, sig, dot <span style="color:#f92672">=</span> tpm_output(w, x)
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">if</span> tau_pred <span style="color:#f92672">==</span> tau_true:
</span></span><span style="display:flex;"><span>                new_pop<span style="color:#f92672">.</span>append(update_weights(w<span style="color:#f92672">.</span>copy(), x, sig, tau_true))
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">else</span>:
</span></span><span style="display:flex;"><span>                i_star <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>argmin(np<span style="color:#f92672">.</span>abs(dot))
</span></span><span style="display:flex;"><span>                sig[i_star] <span style="color:#f92672">*=</span> <span style="color:#f92672">-</span><span style="color:#ae81ff">1</span>
</span></span><span style="display:flex;"><span>                tau_flip <span style="color:#f92672">=</span> np<span style="color:#f92672">.</span>prod(sig)
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">if</span> tau_flip <span style="color:#f92672">==</span> tau_true:
</span></span><span style="display:flex;"><span>                    new_pop<span style="color:#f92672">.</span>append(update_weights(w<span style="color:#f92672">.</span>copy(), x, sig, tau_true))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        population <span style="color:#f92672">=</span> new_pop
</span></span><span style="display:flex;"><span>        print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;[Step </span><span style="color:#e6db74">{</span>t<span style="color:#e6db74">:</span><span style="color:#e6db74">03d</span><span style="color:#e6db74">}</span><span style="color:#e6db74">] Population: </span><span style="color:#e6db74">{</span>len(population)<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> len(population) <span style="color:#f92672">==</span> <span style="color:#ae81ff">0</span>:
</span></span><span style="display:flex;"><span>            print(<span style="color:#e6db74">&#34;[-] nono &#34;</span>)
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> len(population) <span style="color:#f92672">&lt;</span> mthreshold:
</span></span><span style="display:flex;"><span>            print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;[*] Low survivors (</span><span style="color:#e6db74">{</span>len(population)<span style="color:#e6db74">}</span><span style="color:#e6db74">), mutating...&#34;</span>)
</span></span><span style="display:flex;"><span>            survivors <span style="color:#f92672">=</span> population<span style="color:#f92672">.</span>copy()
</span></span><span style="display:flex;"><span>            population <span style="color:#f92672">=</span> []
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">for</span> w <span style="color:#f92672">in</span> survivors:
</span></span><span style="display:flex;"><span>                <span style="color:#66d9ef">for</span> _ <span style="color:#f92672">in</span> range(mfactor <span style="color:#f92672">//</span> max(<span style="color:#ae81ff">1</span>, len(survivors))):
</span></span><span style="display:flex;"><span>                    population<span style="color:#f92672">.</span>append(mutate(w, strength<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span>))
</span></span><span style="display:flex;"><span>            print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;[*]New population after mutation: </span><span style="color:#e6db74">{</span>len(population)<span style="color:#e6db74">}</span><span style="color:#e6db74">&#34;</span>)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    print(<span style="color:#e6db74">f</span><span style="color:#e6db74">&#34;[*]</span><span style="color:#e6db74">{</span>len(population)<span style="color:#e6db74">}</span><span style="color:#e6db74"> survivors. Trying AES decryption...&#34;</span>)
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> w <span style="color:#f92672">in</span> population:
</span></span><span style="display:flex;"><span>        key <span style="color:#f92672">=</span> weight_to_aes_key(w)
</span></span><span style="display:flex;"><span>        pt <span style="color:#f92672">=</span> AES<span style="color:#f92672">.</span>new(key, AES<span style="color:#f92672">.</span>MODE_ECB)<span style="color:#f92672">.</span>decrypt(ct)
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#e6db74">b</span><span style="color:#e6db74">&#34;acsc{&#34;</span> <span style="color:#f92672">in</span> pt:
</span></span><span style="display:flex;"><span>            print(pt<span style="color:#f92672">.</span>decode(errors<span style="color:#f92672">=</span><span style="color:#e6db74">&#34;ignore&#34;</span>))
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">if</span> __name__ <span style="color:#f92672">==</span> <span style="color:#e6db74">&#34;__main__&#34;</span>:
</span></span><span style="display:flex;"><span>    population_attack()
</span></span></code></pre></div>

  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2025 <a href="https://zero.shotlearni.ng/">DoubleMnSingleH</a></span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
